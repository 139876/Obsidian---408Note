# 1.1 操作系统的基本概念

![操作系统的概念、功能.pdf](附件/01.1.1.1+1.1.3%20操作系统的概念、功能.pdf)

## 1.1.1 操作系统的概念

> 什么是操作系统？

操作系统(Operating System，OS)是指控制和管理整个计算机系统的硬件和软件资源，<!--操作系统是系
统资源的管理者-->并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；<!--向上层提供方便易用的服务-->它是计算机系统中最基本的系统软件。<!--是最接近硬件的一层软件-->

## 1.1.3 操作系统的目标和功能

> 操作系统要做些什么？

### 作为计算机系统资源的管理者

* [处理机管理](./第2章%20进程与线程.md)
* [存储器管理](./第3章%20内存管理.md)
* [文件管理](./第4章%20文件管理系统.md)
* [设备管理](./第5章%20输入输出管理.md)

### 向上层提供方便易用的服务

**封装思想**：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可

直接给用户使用的

* GUI图形化用户接口(Graphical User Interface)
* 命令接口
	* 联机命令接口（交互式命令接口）用户说一句，系统做一句
	* 脱机命令接口（批处理命令接口）用户说一堆，系统做一堆

给软件/程序员使用的

* 程序接口：可以在程序中进行**系统调用**来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。 ^[注：系统调用也称为广义指令]

### 作为最接近硬件的层次

需要实现对硬件机器的拓展

没有任何软件支持的计算机称为**裸机**。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器
   
通常把覆盖了软件的机器成为**扩充机器**，又称之为**虚拟机**

## 1.1.2 操作系统的特征

![操作系统的特征.pdf](附件/02.1.1.2%20操作系统的特征.pdf)

并发和共享是两个最基本的特征，二者互为存在条件

### 并发

* **并发**：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的
* **并行**：指两个或多个事件在同一时刻同时发生。

**操作系统的并发性**指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。
操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。

注意：

* **单核CPU**同一时刻只能执行一个程序，各个程序只能并发地执行
* **多核CPU**同一时刻可以同时执行多个程序，多个程序可以并行地执行

### 共享

共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。

* **互斥共享方式**：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。如：QQ和微信无法同时使用摄像头
* **同时共享方式**：系统中的某些资源，允许一个时间段内由多个进程“同时” ^[所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）]对它们进行访问。如：QQ和微信同时发送文件

**并发和共享的联系**

* 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义
* 如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发

### 虚拟

**虚拟**是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。

* 空分复用技术，如虚拟存储器技术
* 时分复用技术，如虚拟处理器

显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性

### 异步

异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。

如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。

# 1.2 操作系统的发展历程

> 重点关注和理解各类操作系统主要想解决的是什么问题，各自的优缺点。

![操作系统的发展与分类.pdf](附件/01.1.2%20操作系统的发展与分类.pdf)

## 1.2.1 手工操作阶段

> 手工装纸带→从纸带机读→计算→向纸带机写→手工取纸带

主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低

## 1.2.2 批处理阶段

### 单道批处理系统

> 将程序读到磁带上，磁带上的一批作业可以自动地逐个运行

引入**脱机输入/输出技术**（用外围机+磁带完成），并由**监督程序**负责控制作业的输入、输出

主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。

主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低。

### 多道批处理系统

> 为了提高利用率，每次往内存中读入多道程序，并允许它们在CPU中交替运行，共享资源

主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。

主要缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。eg：无法调试程序/无法在程序运行过程中输入一些参数）

## 1.2.3 分时操作系统

> 为了实现人机交互功能，比较快速响应用户

**分时操作系统**：计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互

主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。

主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。

## 1.2.4 实时操作系统

> 为了让计算机优先处理紧急任务

主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。

在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性

* **硬实时系统**：必须在绝对严格的规定时间内完成处理，如：自动驾驶系统
* **软实时系统**：能接受偶尔违反时间规定，如：12306火车订票系统

## 1.2.5 网络操作系统和分布式计算机系统

* **网络操作系统**：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT就是一种典型的网络操作系统，网站服务器就可以使用）
* **分布式操作系统**：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。
* **个人计算机操作系统**：如Windows XP、MacOS，方便个人使用。

# 1.3 操作系统运行环境


![操作系统的运行机制.pdf](附件/01.1.3.1%20操作系统的运行机制.pdf)

### 预备知识：程序是如何运行的

C语言代码→机器指令（二进制）

“指令”就是处理器（CPU）能识别、执行的最基本命令

注：很多人习惯把Linux、Windows、MacOS的“小黑框”中使用的命令也称为“指令”，其实这是“交互式命令接口”，注意与本节的“指令”区别开。本节中的“指令”指二进制机器指令

### 两种程序与两种指令

* **内核程序**，很多内核程序组成了“操作系统内核”，内核是操作系统最重要最核心的部分，也是最接近硬件的部分，甚至可以说一个操作系统只要有内核就够了（例：Docker仅需Linux内核）
	* 操作系统内核作为“管理者”，有时会让CPU执行一些“**特权指令**”，如：内存清零指令。这些指令影响重大，只允许“管理者”——即操作系统内核来使用
* **应用程序**，普通程序员写的程序
	* 应用程序只能使用“**非特权指令**”，如：加法指令、减法指令等

在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型

**常见特权指令** ^fa8fb9

* 有关对I/O设备操作的指令
* 有关访问程序状态的指令
* 存取特殊寄存器指令

### 两种处理器状态

> CPU能判断出指令类型，但是它怎么区分此时正在运行的是内核程序or应用程序？

* CPU中有一个寄存器叫做**程序状态字寄存器**(`PSW`)，其中有一个二进制位0表示内核态，1表示用户态
* 处于**内核态**（核心态、管态）时，说明此时正在运行的是内核程序，此时可以执行特权指令<!--可以执行除“访管”指令的全部指令，此时没必要使用访管指令-->
* 处于**用户态**（目态）时，说明此时正在运行的是应用程序，此时只能执行非特权指令

#### 内核态与用户态的切换

* **内核态→用户态**：执行一条特权指令——修改`PSW`的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权
* **用户态→内核态**：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU使用权（除了非法使用特权指令之外，还有很多事件会触发中断信号。一个共性是，但凡需要操作系统介入的地方，都会触发中断信号）

## 1.3.1 处理器运行模式

与硬件紧密相关的模块、各种常用设备的驱动程序、运行频率较高的模块一般都安排在OS内核中，常驻内存。运行在内核态

大多数操作系统的内核包括以下4个方面的内容：

### 时钟管理

实现计时模式

### 中断处理

负责实现中断机制

### 原语操作

按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。它们的特点如下：

* 处于操作系统的最底层，是最接近硬件的部分
* 这些程序的运行具有**原子性**，其操作只能一气呵成，期间不允许被中断。可以使用关中断指令和开中断指令来实现原子性。 ^[CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查]
* 这些程序的运行时间都比较短，而且调用频繁

通常把具有这些特点的程序称为**原语**。定义原语的直接方法是关闭中断，让其所有动作不可分割地完成后再打开中断。

系统中设备驱动、CPU切换、进程通信等功能中的部分操作都可定义为原语，使它们称为内核的组成部分

### 系统控制的数据结构及处理

> 这些管理工作更多的是对数据结构的管理，不会直接涉及硬件

* 进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块等
* 存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序
* 设备管理：缓冲区管理、设备分配和回收等

## 1.3.2 中断和异常的概念


> 可以联系计组[异常和中断机制](../2%20计算机组成原理/第5章%20中央处理器#5.5%20异常和中断机制)与[输入输出系统](../2%20计算机组成原理/第7章%20输入输出系统#7.3.2%20程序中断方式)

![中断和异常.pdf](附件/02.1.3.2%20中断和异常.pdf)

### 中断的作用

CPU上会运行两种程序，一种是操作系统内核程序，一种是应用程序。在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序（[第2章 进程与线程](第2章%20进程与线程.md)相关内容）。“中断”是让操作系统内核夺回CPU使用权的唯一途径。如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序

### 中断的类型

#### 内中断

> 也称**异常**、例外，与当前执行的指令有关，中断信号来源于CPU内部

* 例子1：试图在用户态下执行特权指令
* 例子2：执行除法指令时发现除数为0
* 例子3：有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个内部中断信号（执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内。 “系统调用”就是通过陷入指令完成的）

按照异常发生原因和返回方式不同，可分为故障、自陷和终止：

* **故障**(Fault)：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把CPU使用权还给应用程序，让它继续执行下去。如：[缺页](第3章%20内存管理#缺页中断机构)故障。<u>返回当前指令</u>。
  > 补充：Cache失效与虚拟存储器失效的处理方法不同，Cache完全由硬件实现，不涉及软件端；虚拟存储器由硬件和OS共同完成，缺页时才会发出缺页中断
* **异常**、**陷入**(Trap)：（陷入指令=trap指令=访管指令）由陷入指令引发，是应用程序故意引发的，CPU会自动根据不同“陷阱“类型进行相应的处理，然后返回到自陷指令的<u>下一条指令</u>执行（当自陷指令是转移指令时，返回到转移目标指令执行）
* **终止**(Abort)：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是<u>直接终止该应用程序</u>。如：整数除0、非法使用特权指令

#### 外中断

> 也称**中断**，与CPU当前执行的指令无关，中断信号来源于CPU外部；每一条指令执行结束时，CPU都会例行检查是否有外中断信号。<u>返回下一条指令</u>。

包括I/O设备发出的I/O中断（如键盘输入、打印机缺纸），或发生某种特殊事件（如用户按Esc键、定时器技术时间到）等。外部I/O设备通过特定的中断请求信号线向CPU提出中断请求，CPU每执行完一条指令就检查中断请求信号线，如果检测到中断请求，则进入中断响应周期。

* 例子1：<u>时钟中断——由时钟部件发来的中断信号</u>
* 例子2：I/O中断——由输入/输出设备发来的中断信号

中断可分为可屏蔽中断和不可屏蔽中断

* **可屏蔽中断**：通过可屏蔽中断请求线INTR向CPU发出的中断请求。CPU可以通过在中断控制器中设置响应的[屏蔽字](第7章%20输入输出系统#多重中断和中断屏蔽技术)来屏蔽它或不屏蔽它。被屏蔽的中断请求将不被送到CPU
* **不可屏蔽中断**：指通过专门的不可屏蔽中断请求线NMI向CPU发出的中断请求，通常是非常紧急的硬件故障，如电源掉电等。这类中断请求信号不可被屏蔽，以让CPU快速处理这类紧急事件

#### 异常vs中断

* 异常的检测由CPU自身完成，不必通过外部的某个信号通知CPU。
* 对于中断，CPU必须通过中断请求线获取中断源的信息，才能知道哪个设备发生了何种中断

### 中断机制的基本原理

不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。

显然，中断处理程序一定是内核程序，需要运行在“内核态”

## 1.3.3 系统调用


![系统调用.pdf](附件/03.1.3.3%20系统调用.pdf)


### 什么是系统调用

操作系统作为用户和计算机硬件之间的接口，需要[向上提供一些简单易用的服务](#向上层提供方便易用的服务)。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。

补充：系统调用是操作系统为应用程序使用内核功能所提供的接口，因此系统调用只能通过用户程序间接使用。

### 系统调用与库函数的区别

1. 裸机
2. 操作系统：向上提供系统调用，使得上层程序能请求内核的服务
3. 编程语言：向上提供库函数，有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便
4. 普通应用程序：可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及

### 什么功能要用到系统调用

应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此<u>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等）</u>，都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。

* 设备管理：完成设备的请求、释放、启动等功能
* 文件管理：完成文件的读写、创建、删除等功能
* 进程控制：完成进程的创建、撤销、阻塞、唤醒等功能
* 进程通信：完成进程之间的消息传递、信号传递等功能
* 内存管理：完成内存的分配、回收等功能

### 系统调用的过程

![第1章-系统调用执行过程.drawio](图表/第1章-系统调用执行过程.drawio.svg)

注意：

* 陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态
* 发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行

# 1.4 操作系统结构

> 操作系统的内核该如何设计？

![操作系统体系结构（上）.pdf](附件/01.1.4%20操作系统体系结构（上）.pdf)

![操作系统体系结构（下）.pdf](附件/02.1.4%20操作系统体系结构（下）.pdf)

### 分层结构

* 特性：内核分多层，每层可单向调用更低一层提供的接口。最底层是硬件，最高层是用户接口
* 优点
	* 便于调试和验证，自底向上逐层调试验证
	* 易于扩充和维护，各层之间调用接口清晰固定
* 缺点
	* 仅可调用相邻底层，但有时又难以合理定义各层的边界
	* 效率低，不可跨层调用，系统执行时间长

### 模块化

* 特性：将操作系统按功能划分为若干个具有一定独立性的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能通过接口进行通信。还可以进一步将各模块细分为若干个具有一定功能的子模块，同样也规定好各子模块之间的接口。把这种设计方法称为模块-接口法
	* 主模块：只负责核心功能，如进程调度、内存管理
	* 可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核
* 优点
	* 模块间逻辑清晰易维护，确定模块接口后即可多模块同时开发
	* 支持动态加载新的内核模块（如：安装设备驱动程序、安装新的文件系统模块到内核），增强操作系统适应性
	* 任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高
* 缺点
	* 模块间的接口定义未必合理、实用
	* 模块间相互依赖，更难调试和验证

### 大内核

* 大内核，又名宏内核、单内核，是将[系统的主要功能模块](#1.3.1%20处理器运行模式)都作为一个紧密联系的整体运行在内核态，从而为用户程序提供高性能的系统服务。如：Linux、Unix

* 优点：性能高，内核内部各种功能都可以直接相互调用
* 缺点
	* 内核代码庞大、结构混乱，难以维护
	* 大内核中某个功能模块出错，就可能导致整个系统崩溃

### 微内核

将内核中最基本的功能保留在内核，而将那些[不需要在核心态执行的功能](#系统控制的数据结构及处理)移动到用户态执行，从而降低内核的设计复杂性。如：Windows NT

* 优点
	* 内核功能少，结构清晰，方便维护，可靠性高
	* 内核外的某个功能模块出错不会导致整个系统崩溃
* 缺点
	* 需要频繁地在核心态和用户态之间切换，性能低。
	* 用户态下的各个功能模块不可以直接相互调用，只能通过内核的“消息传递”来间接通信

| |大内核|微内核|
|:----:|:----:|:----:|
|复杂性|更高|更低👍|
|可维护性性|更低|更高👍|
|可靠性|更低|更高👍|
|可移植性|更差|更好👍|
|可扩展性|更差|更好👍|
|占用内存空间|更多|更少👍|
|性能(效率)|更高👍|更低|
|状态切换开销|更低👍|更高|

### 外核

* 内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且外核负责保证资源使用安全
* 优点
	* 外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户可以更灵活的使用硬件资源
	* 减少了虚拟硬件资源的“映射层”，提升效率
* 缺点
	* 降低了系统的一致性
	* 使系统变得更复杂

# 1.5 操作系统引导

> 开机的时候，怎么让操作系统运行起来

![操作系统引导.pdf](附件/01.1.5%20操作系统引导.pdf)

![第1章-操作系统引导.drawio](图表/第1章-操作系统引导.drawio.svg)

BIOS(Basic Input/Output System)，基本输入输出系统，保存在内存ROM区域中的固定程序。
> BIOS→硬盘→MBR→硬盘分区→PBR→操作系统
1. **激活CPU。** 激活的CPU读取ROM中的boot程序，将指令寄存器置为BIOS的第一条指令，即开始执行BIOS的指令；
2. **硬件自检。** 启动BIOS程序，先进行硬件自检，检查硬件是否出现故障。如有故障，主板会发出不同含义的蜂鸣，启动终止；如无故障，屏幕会显示CPU、内存、硬盘等信息；
3. **加载带有操作系统的硬盘。** 硬件自检后，BIOS开始读取Boot Sequence（通过CMOS里保存的启动顺序，或者通过与用户交互的方式），把控制权交给启动顺序排在第一位的存储设备，然后CPU将该存储设备引导扇区的内容加载到内存中；
4. **加载主引导记录MBR。** 硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现一个存储设备不是可引导盘，就检查下一个存储设备。如无其他启动设备，就会死机。主引导记录的作用是告诉CPU去硬盘的哪个分区去找操作系统；
5. **扫描硬盘分区表，并加载硬盘活动分区。** 主引导记录包含**磁盘引导程序**和**磁盘分区表**，磁盘分区表以特定的标识符区分活动分区和非活动分区。主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区；
6. **加载分区引导记录PBR。** 包含**分区引导程序**。读取活动分区的第一个扇区（即分区引导记录PBR, Partition Boot Record），寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）
7. **加载启动管理器。** 启动管理器也称**操作系统引导程序**或操作系统初始化程序。
8. **加载操作系统**

# 1.6 虚拟机


![虚拟机.pdf](附件/01.1.6%20虚拟机.pdf)


虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(Virtual Machine, VM)，每个虚拟机器都可以独立运行一个操作系统

* 同义术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor(VMM)/Hypervisor

* **第一类VMM**：直接运行在硬件上（只有虚拟机管理程序运行在内核态，上层操作系统运行在用户态）

![第1章-第一类VMM.drawio](图表/第1章-第一类VMM.drawio.svg)

* **第二类VMM**：运行在宿主操作系统上（虚拟机管理程序运行在用户态和内核态）

![第1章-第二类VMM.drawio](图表/第1章-第二类VMM.drawio.svg)

两种虚拟管理程序对比

|                    | 第一类VMM                                                    | 第二类VMM                                                    |
| :----------------: | :----------------------------------------------------------- | ------------------------------------------------------------ |
| 对物理资源的控制权 | 直接运行在硬件之上，能直接控制和分配物理资源                 | 运行在Host OS之上，依赖于Host OS为其分配物理资源             |
|    资源分配方式    | 在安装Guest OS时，VMM要在原本的硬盘上自行分配存储空间，类似于[外核](#外核)的分配方式，分配未经抽象的物理硬件 | Guest OS拥有自己的虚拟磁盘，该盘实际上是Host OS文件系统中的一个大文件。Guest OS分配到的内存是虚拟内存 |
|        性能        | 性能更好                                                     | 性能更差，需要Host OS作为“中介                               |
| 可支持的虚拟机数量 | 更多，不需要和Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机 | 更少，Host OS本身需要使用物理资源，Host OS上运行的其他进程也需要物理资源 |
|  虚拟机的可迁移性  | 更差                                                         | 更好，只需导出虚拟机镜像文件即可迁移到另一台Host OS上，商业化应用更广泛 |
|      运行模式      | 第一类VMM运行在最高特权级(Ring 0)，可以执行最高特权的指令。  | 第二类VMM部分运行在用户态、部分运行在内核态。Guest OS发出的系统调用会被VMM截获，并转化为VMM对Host OS的系统调用 |

支持虚拟化的CPU通常分更多指令等级

* Ring 0：最高权限的一些指令
* Ring 3：最低权限的一些指令