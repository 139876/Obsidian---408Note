# 3.1 存储器概述

![存储系统基本概念.pdf](附件/01.3.1%20存储系统基本概念.pdf)
## 3.1.1 存储器的分类

### 按层次分类

* 高速缓存(Cache)（可直接被CPU读写）
* 内存（主存）（可直接被CPU读写）
* 辅存：磁盘
* 外存：磁带、光盘

### 按存储介质分类

* 半导体存储器：以半导体器件存储信息。
* 磁表面存储器：以磁性材料存储信息，如：磁盘、磁带
* 光存储器：以光介质存储信息，如：光盘

### 按存取方式分类

* **随机存取存储器RAM**：Random Access Memory，随机存取指CPU可以对RAM的任一单元随机地读写，且对任一单元的读出和写入时间相同，读写任意存储单元的时间与物理地址无关。根据存储单元工作原理的不同，可进一步细分为静态RAM和动态RAM，详见：[3.2.1 SRAM 芯片和 DRAM 芯片](#3.2.1%20SRAM%20芯片和%20DRAM%20芯片)
* **只读存储器ROM**：Read-Only Memory，同样具备随机访问的特性，但ROM中的信息一经写入，之后只能读取，不能再次写入。现如今部分种类的ROM也具有了多次写入的功能，但与RAM相比，写入速度比读取速度慢很多。详见：[3.2.2 只读存储器](#3.2.2%20只读存储器)
* **顺序存取存储器SAM**：Sequential Access Memory，访问数据时，必须顺着存储单元的物理地址顺序顺次访问，即串行访问，如磁带。<u>存储时间与存取的物理地址有关</u>
* **直接存取存储器DAM**：Direct Access Memory，访问数据时，先通过随机访问确定一个较小的存储区域，再在这小区域内顺序查找，如机械硬盘。<u>存取时间与存取的物理地址有关</u>
* **相联存储器AM**：Associative Memory，<u>可以按内容或地址访问</u>的存储器(Content Addressed Memory, CAM)，可以按照内容检索到存储位置进行读写，如快表

### 按信息的可保存性分类

* 易失性存储器：断电后，存储信息消失的存储器。如：RAM
* 非易失性存储器：断电后，存储信息依然保持的存储器。如：ROM、磁盘、光盘
* 破坏性读出：信息读出后，原存储信息被破坏，需要进行重写。如：DRAM
* 非破坏性读出：信息读出后，原存储信息不被破坏。如：SRAM，ROM、磁盘、磁带、光盘

## 3.1.2 存储器的性能指标

* **存储容量**：<u>存储字数×字长</u>（如：1M×8 位），MDR位数反映存储字长
	* 数据线和地址线数共同反映存储体容量的大小。对于[DRAM](#DRAM的地址线复用技术)地址线数量减半
* **单位成本**：每位价格=总成本/总容量
* **存储速度**：数据传输率=数据的宽度/存储周期，数据的宽度即存储字长
	* **存取时间** $T_{a}$：是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间
	* **存取周期** $T_{m}$：又称读写周期或访问周期，是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作（读或写操作）之间所需的最小时间间隔（<u>存取周期=存取时间+恢复时间</u>）（机器周期通常由存取周期决定）
	* **主存带宽** $B_{m}$：又称数据传输率，表示每秒从主存进入信息的最大数量，单位为字/秒、字节/秒或位/秒

## 3.1.3 多级层次的存储系统

解决存储系统大容量、高速度和低成本三个相互制约的矛盾

1. CPU
2. 寄存器
3. 高速缓存——Cache
4. 内存——主存
5. 辅存——磁盘
6. 外存——磁带、光盘

![第3章-三级存储系统.drawio](图表/第3章-三级存储系统.drawio.svg)

* Cache-主存层：解决了主存与CPU速度不匹配的问题。主存和 Cache 之间的数据调动是由硬件自动完成的，对**所有程序员均是透明**的
* 主存-辅存层：实现了虚拟存储系统，解决了主存容量不够的问题，辅存中的数据要调入主存后才能被CPU访问。 主存和辅存之间的数据调动是由硬件和操作系统共同完成的，对**应用程序员透明**^[**系统程序员**是编写诸如操作系统、编译程序等各种系统软件的人员，<br>**应用程序员**是指利用计算机及所配的系统软件支持来编写解决具体问题的程序员] #考前记一记 

# 3.2 主存储器

主存储器由DRAM和ROM组成，前者一般预留给用户，后者则存储各种固定程序和数据
注：现在的主存通常采用SDRAM芯片

## 3.2.3 主存储器的基本组成

![主存储器的基本组成.pdf](附件/01.3.2.0+3.2.3%20主存储器的基本组成.pdf)
### 基本半导体元件的原理

[存储元](./第1章%20计算机系统概述.md#^d73be5)=电容+MOS管
* **MOS管**：可理解为一种电控开关，输入电压达到某个阈值时，MOS管就可以接通
* **电容**：规定电容内存储电荷时，为1，否则为0
读写操作的实现
* 读：MOS管接通后，若电容放电，数据线上产生电流，则存储的数据为1；否则若数据线上无电流，则为0
* 写：MOS管接通后，若数据线给予电压，则电容充电，存储数据1

### 存储芯片的基本原理

![存储器芯片](图表/第3章-存储器芯片.drawio.svg)
* 片选线： 芯片选择信号$\overline{CS}$ (chip select) 或芯片使能信号 $\overline{CE}$ (chip enable)，横线表示低电平有效
	* 补充：SRAM 片选线 1 条；DRAM 由于行列地址复用，片选线两条
* 两根读写线：$\overline{WE}$ 允许写；$\overline{OE}$ 允许读
* 一根读写线：$\overline{WE}$ 低电平写、高电平读

---
* 译码驱动电路：译码器将地址信号转化为字选通线的高低电平、驱动器保证输出的电信号稳定可靠
* 存储矩阵（存储体）：由多个存储单元构成，每个存储单元又由多个存储元构成
* 读写电路：每次读/写一个存储字
* 地址线$A_{i}$、数据线$D_{i}$、片选线、读写控制线（可能分开两根，也可能只有一根）、供电引脚、接地引脚
![](图表/第3章-存储结构.drawio.svg)

---
* 读：当CPU要读取主存储器的数据时，CPU将待访问的主存地址传入MAR，并让MAR将地址通过地址总线传入主存的译码器；同时CPU通过读写控制线向主存的控制电路发出读信号。主存收到信号后，通过译码驱动将地址信号转变为选择信号，选定指定存储单元并读出数据到地址总线上传给MDR
* 写：当CPU要想主存储器写入数据时，CPU将待写入的主存地址传入MAR，并让MAR将地址通过地址总线传入主存的译码器。同时CPU通过读写控制线向主存的控制电路发出写信号。CPU将待写入的数据传输MDR，并让MDR通过数据总线传入主存的读写电路。主存收到信号后，通过译码驱动将地址信号转变为选择信号，选定存储单元并将数据写入该存储单元

### 如何实现不同的寻址方式

现代计算机通常按字节编址，即每个字节对应一个地址

按字节寻址、按字寻址、按半字寻址、按双字寻址

## 3.2.1 SRAM 芯片和 DRAM 芯片

![SRAM和DRAM.pdf](附件/02.3.2.1%20SRAM和DRAM.pdf)

* DRAM，Dynamic Random Access Memory，即动态随机存储器，用于制造主存。动态是指存储器必须每隔一定时间进行一次刷新操作，并且在读取后也需要进行恢复
* SRAM，Static Random Access Memory，即静态随机存储器，用于制造Cache。静态是指存储器只要保持通电，里面存储的数据就可以一直保持而不需要刷新，也不会因为读操作而被破坏。

### 存储元件不同导致的特性差异

DRAM芯片使用**栅极电容**存储信息，而SRAM芯片使用**双稳态触发器**存储信息

* [栅极电容](#基本半导体元件的原理)：1个电容+1个MOS管
	* 读出1时：MOS管接通，电容放电，数据线上产生电流
	* 读出0时：MOS管接通，数据线上无电流
	* 电容放电，信息被破坏，是破坏性读出，读出后应有重写操作，也称“再生”，读写速度更快
	* 每个存储元制造成本更低，集成度更高，功耗更低
	* 电容内的电荷只能维持2ms，即便不断电，2ms后信息也会消失，所以2ms以内必须刷新一次（给电容充电）
* 双稳态触发器：6个MOS管，2根数据线
	* 读出1时：A高电平B低电平，BLX为低电平
	* 读出0时：A低电平B高电平，BL为低电平
	* 读出数据，触发器状态保持稳定，是非破坏性读出，无需重写，读写速度更快
	* 每个存储元制造成本更高，集成度更低，功耗更大
	* 只要不断电，触发器的状态就不会改变

|  类型特点  |     SRAM     |    DRAM    |
|:----------:|:------------:|:----------:|
|  存储信息  | 双稳态触发器 |  栅极电容  |
| 破坏性读出 | 非破坏性读出 | 破坏性读出 |
| 需要重写？ |     不用     |    需要    |
|  运行速度  |      快      |     慢     |
|   集成度   |      低      |     高     |
|   发热量   |      大      |     小     |
|  存储成本  |      高      |     低     |
|   易失性   |     易失     |    易失    |
| 需要刷新？ |    不需要    |    需要    |
| 送行列地址 |    同时送    |  分两次送  |
|    用途    | 常用作Cache  | 常用作主存 |


### DRAM的刷新

* 由于电容会漏电，所以DRAM的存储单元必须时常刷新，否则会因漏电导致数据丢失
* 刷新周期：与存储周期等长，一般为2ms
* 每次刷新多少存储单元：<u>以行为单位</u>，每次刷新一行存储单元 ^[使用行列地址来减少选通线的数量。$n$ 位行地址拆分为行列地址（DRAM一般行、列地址等长，前半部分作为行地址，后半部分作为列地址）]
* 如何刷新？：硬件支持，读出一行的信息后重新写入，占用一个读/写周期
* 什么时候刷新？
	* **集中刷新**：在允许的最大刷新间隔内，按照存储芯片容量的大小，在若干读写周期后，几种安排几个读写周期用于刷新操作，在此期间停止读写操作，故被称为“访存死区”或**死时间
	* **分散刷新**：将每一个存储周期的内部都分为两段，前一段正常读写（时长为原来的一个存储周期），后一段时间用于刷新（时长为刷新一行的时间），从而避免死时间。如此做会增大存储周期，降低了DRAM的读写能力，况且当存储容量比较少时刷新过于频繁，无法充分利用允许的最大刷新间隔。
	* **异步刷新**：综合两种方式，使得在一个刷新周期内，每一行被刷新且仅刷新一次。
* DRAM的刷新需要注意以下问题： #考前记一记 
	* 刷新由存储器独立完成，对CPU是透明的，即刷新不依赖于外部的访问；
	* 动态RAM的刷新单位是行，由芯片内部自行生成行地址；
	* 刷新操作类似读操作，但又有所不同。另外刷新时不需要选片，即整个存储器中的所有芯片同时被刷新
### DRAM的地址线复用技术

* **行列地址复用技术**：把行地址和列地址通过前后两次分别进行传输，分别送给行地址译码器和列地址译码器，从而让地址线数目减半 #易错 （计算引脚数时）
	* 行列数无法相等时，优先令行数小于列数，从而减少刷新次数
* DRAM使用地址复用技术，而SRAM不使用，这是因为DRAM的大小较SRAM大很多，所以引入行列地址复用技术能有效减少芯片引脚数目

## 3.2.2 只读存储器

![只读存储器ROM.pdf](附件/03.3.2.2%20只读存储器ROM.pdf)

* 与RAM不同，只读存储器ROM中的数据一经写入就不轻易改变，即使断电也不失去信息，属于非易失性存储器。
* 与RAM相同，只读存储器ROM通常采取随机存取的访问方式

### 各种ROM

- **MROM**：(Mask Read-Only Memory)——掩模式只读存储器，厂家按照客户需求，在芯片生产过程中直接写入信息，之后任何人不可重写，只能读出。可靠性高、灵活性差、生产周期长，只适合批量定制
- **PROM**：(Programmable Read-Only Memory)——可编程只读存储器，用户可用专门的PROM写入器写入信息，写一次之后就不可更改
- **EPROM**：(**Erasable** Programmable Read-Only Memory)——可擦除可编程只读存储器，允许用户写入信息，之后用某种方法擦除数据，可进行多次重写
- **UVEPROM**(ultraviolet rays)：用紫外线照射8~20分钟，擦除所有信息
- **EEPROM**(也称E$^{2}$PROM，第一个E指的是Electrically)：可用电擦除的方式，擦除特定的字
- **闪存**：Flash Memorry——闪速存储器（如U盘，SD卡），在EEPROM的基础上发展而来，断电后也能保存信息，且可进行多次快速擦除重写。（也属于ROM）
	* 由于闪存需要先擦除再写入，因此闪存的写速度要比读速度更慢
	* 每个存储元只需要单个MOS管，位密度比RAM高
- **SSD**：(Solid State Drives)——固态硬盘，由控制单元+存储单元（Flash芯片）构成，与闪速存储器的核心区别在于控制单元不一样，但存储介质都类似，可进行多次重复擦除重写
	- SSD速度快，功耗低，目前个人电脑上常用SSD取代传统的机械硬盘
- **CD-ROM**：属于光盘存储器，是一种机械式的存储器，与ROM有本质的区别，其名字中有ROM只是为了突出只读而已。 #考前记一记 

### 计算机内部的重要ROM

* BIOS芯片：主板上的BIOS（ROM）芯片存储了“自举装入程序”，负责引导装入操作系统（开机）
* 通常说的内存条就是主存，但事实上，主板上的ROM芯片也是主存的一部分
* 逻辑上，主存由RAM+ROM组成，且二者常统一编址（前后编号相连）

## 3.2.4 多模块存储器与双端口RAM

* 由于DRAM芯片的恢复时间比较长，有可能是存取时间的几倍
> - 多核CPU都要访存，怎么办？——双端口RAM
> - CPU的读写速度比主存快很多，主存恢复时间太长怎么办？——多模块存储器

![双端口RAM和多模块存储器.pdf](附件/04.3.2.4%20双端口RAM和多模块存储器.pdf)

### ~~双端口RAM~~

双端口RAM：优化多核CPU访问一根内存条的速度

* 需要有两组完全独立的数据线、地址线、控制线。CPU、RAM中也要有更复杂的控制电路
* 两个端口对同一主存操作有以下4种操作：
	* 两个端口同时对不同的地址单元存取数据——可行
	* 两个端口同时对同一地址单元读出数据——可行
	* 两个端口同时对同一地址单元写入数据——写入错误
	* 两个端口同时对同一地址单元，一个写入数据，一个读出数据——读出错误（可以联系[读者写者问题](第2章%20进程与线程#读者-写者问题)）
* 解决方案：置“忙”信号为0，由判断逻辑决定暂时关闭一个端口（被延时），未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问

### 多模块存储器

* **单体多字存储器**：只有一套读写控制电路、地址寄存器和数据寄存器，类似位扩展
	* 每次只能读 $m$ 个字，不能单独存取其中某一个字。而且指令和数据在主存内必须是单独存放的
	* 总线宽度也要扩展为 $m$ 个字
* **多体并行存储器**：每个模块都有相同的容量和存取速度，各个模块都有独立的读写控制电路、地址寄存器和数据寄存器，它们既能并行工作，又能交叉工作。多提并行存储器又分为高位并行存储器和低位交叉存储器：
	* **高位交叉编址**：主存地址的高位确定选择哪一个模块，低位选定模块内的内部地址。地址在模块内连续，连续取 $n$ 个存储字耗时 $nT$
		* 理论上多个存储体可以被并行访问，但由于通常会连续访问，因此实际效果相当于单纯的扩容
	* **低位交叉编址**：主存地址的低位确定选择哪一个模块，高位选定模块的内部地址。
		* 按地址连续访问时，会轮流访问各个内存条
		* 存取周期为 $T$，存取时间为 $r$，连续取 $n$ 个存储字耗时 $T+(n-1)r$；
		* 为了保证流水线不间断，应保证模块数 $m\geqslant T/r$，并且最好可以让 $m=T/r$ 
		* 微观上，$m$ 个模块被串行访问；宏观上，每个存取周期内所有模块被并行访问

![第3章-低位交叉编址存储方式.drawio](图表/第3章-低位交叉编址存储方式.drawio.svg)

# 3.3 主存储器与CPU的连接

![主存储器与CPU的连接.pdf](附件/01.3.3%20主存储器与CPU的连接.pdf)
## 3.3.2 主存容量的扩展

### 字扩展
> 字扩展可以增加存储器的存储字数，更好的利用CPU的寻址能力

**字扩展**：仅在字数方向扩展，加大地址空间的大小，而不加大存储单元的字长，也称**容量扩展**或地址总线扩展。
* 将所有存储芯片的数据线各自并联后与CPU的数据线连接；
* 将所有存储芯片的地址线各自并联后与CPU的地址线连接；
* 将所有存储芯片的读写控制线并联后与CPU的读写控制线连接；
* 各存储芯片的片选控制线与CPU多余的地址线连接。根据片选信号产生的不同，分为[线选法](#线选法)和[译码片选法](#译码片选法)

#### 线选法

* **线选法**：$n$ 条线对应 $n$ 个片选信号，电路简单，地址空间不连续
* 例如下图所示结构中， $A_{13}\sim A_{15}$ 每根线控制一个片，$A_{13}\sim A_{15}$ 只能有1位是1，所以地址上就造成了浪费


![线选法](pictures/第3章%20存储系统%20线选法.png)

#### 译码片选法

* **片选法**：$n$ 条线对应 $2^{n}$ 个选片信号，电路复杂，地址空间可连续
* 例如下图所示结构中，$A_{13}\sim A_{15}$ 三根线控制八个片

![译码片选法](pictures/第3章%20存储系统%20译码片选法.png)

### 位扩展
> 位扩展使存储器的字长变长，从而更好的发挥数据总线的数据传输能力

**位扩展**：仅在位数方向上扩展（加大存储字长），又称**字长扩展**或数据总线扩展，当存储芯片的数据总线位宽小于CPU数据总线位宽时，采用位扩展的方式进行扩展。
* 各存储芯片的数据线分别与CPU的不同数据线连接；
* 将所有存储芯片的地址线各自并联后与CPU的地址线连接；
* 将所有存储芯片的读写控制线并联后与CPU的读写控制线连接；
* 将所有存储芯片的片选控制线并联后与CPU的访存请求信号相连。

![位扩展](pictures/第3章%20存储系统%20位扩展.png)

### 字位同时扩展

**字位同时扩展**：同时增加单个存储单元大小和存储芯片的地址空间大小。
* 所有存储芯片分组，组内的芯片进行位扩展，不同组的芯片进行字扩展
* 将不同组存储芯片的数据线各自并联，同组内各芯片的数据线分别与CPU的不同数据线连接；
* 将所有存储芯片的地址线各自并联后与CPU的地址线连接；
* 将所有存储芯片的读写控制线并联后与CPU的读写控制线连接；
* 将同组内存储芯片的片选控制线并联，不同组的片选控制线与CPU多余的地址线连接

![字位同时扩展](pictures/第3章%20存储系统%20字位同时扩展.png)

现在的计算机MAR、MDR通常集成在CPU内部。存储芯片内只需要一个普通的寄存器（暂存输入、输出数据)

## 3.3.3 存储芯片的地址分配和片选

关于译码器

* 使能端EN：类似片选信号$CS$，
* 多个使能端G：CPU可能使用译码器的使能端控制片选信号的生效时间
	* 如使能端 $G_{1},\overline{G_{2A}},\overline{G_{2B}}$ 表示只有 $G_{1}\overline{G_{2A}}\overline{G_{2B}}=101$ 时译码器工作，否则输出端 $\overline{Y_{0}}\,\overline{Y_{1}}\,\overline{Y_{2}}\,\overline{Y_{3}}\,\overline{Y_{4}}\,\overline{Y_{5}}\,\overline{Y_{6}}\,\overline{Y_{7}}=11111111$（`74ls138`译码器）
* 当译码器低电平有效时，输入端 $A_{1}A_{2}A_{3}=101$ 对应输出端 $\overline{Y_{0}}\,\overline{Y_{1}}\,\overline{Y_{2}}\,\overline{Y_{3}}\,\overline{Y_{4}}\,\overline{Y_{5}}\,\overline{Y_{6}}\,\overline{Y_{7}}=11111011$

![译码器](pictures/第3章%20存储系统%20译码器.jpeg)

# 3.4 外部存储器

## 磁盘存储器
> 结合[磁盘](../3%20操作系统/第5章%20输入输出管理#5.3.1%20磁盘)

![磁盘存储器.pdf](附件/01.3.4.1%20磁盘存储器.pdf)

* 计算机的外存储器又称为辅助存储器，目前主要使用磁表面存储器
* **磁表面存储**：磁表面存储是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器均属于磁表面存储器（每次读写都是1bit，且读写不能同时进行）
* 优点：存储容量大，位价格低；记录介质可以重复使用；记录信息可以长期保存而不丢失，甚至可以脱机存档；非破坏性读出，读出时不需要再生
* 缺点：存取速度慢；机械结构复杂；对工作环境要求高

### 磁盘设备的组成

* 存储区域：一块硬盘含有若干个**记录面**，每个记录面划分为若干条**磁道**，而每条磁道又划分为若干个**扇区**。扇区（也称块）是磁盘读写的最小单位，也就是说磁盘按块存取
	* **磁头数**：即记录面数，表示硬盘一共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头
	* **柱面数**：表示磁盘每一面盘片上有多少磁道。在一个盘组中，不同记录面的相同编号（位置）的多个磁道构成一个圆柱面
	* **扇区数**：表示每条磁道上有多少个扇区
* 硬盘存储器：硬盘存储器由硬盘驱动器、硬盘控制器和盘片组成
	* **磁盘控制器**：CPU与磁盘驱动器之间的接口，负责接收CPU发来的命令，将其转换成磁盘驱动器的控制命令，并实现CPU与驱动器之间的数据格式转换
	* **磁盘驱动器**：负责接收磁盘控制器的控制命令，并控制磁头组件和盘片组件进行读写操作

### 磁盘的性能指标

* 磁盘的容量：一个磁盘所能存储的字节总数称为**磁盘容量**
	* **非格式化容量**是指磁记录表面可以利用的磁化单元总数（大）
	* **格式化容量**是指按照某种特定的记录格式所能存储信息的总量（小）
* 记录密度：盘片单位面积上记录的二进制的信息量
	* **道密度**：沿磁盘半径方向单位长度上的磁道数
	* **位密度**：磁道单位长度上能记录的二进制代码位数
	* **面密度**：位密度与位密度的乘积
	* 磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同
* [**平均存取时间**](../3%20操作系统/第5章%20输入输出管理#读写操作所需时间)：平均存取时间=磁盘控制器延迟时间+平均寻道时间（磁头移动到目的磁道）+平均旋转延迟时间（磁头定位到所在扇区，取旋转半圈所需的时间）+传输时间（传输数据所花费的时间） 
* **数据传输率**：磁盘存储器单位时间内向主机传送数据的字节数
	* 数据传输率 $D_{r}=rN$，其中 $r$ 为磁盘转速，单位转/秒，$N$ 为磁道的容量，单位字节/磁道，$D_{r}$ 单位为字节/秒
	* 补充：RPM表示转/分钟
* 误码率：是衡量磁表面存储器出错概率的参数，误码率=出错信息位数/读出的总信息位数

### 磁盘地址

驱动器号+柱面（磁道）号+盘面号+扇区号，磁道在寻址时，应先确定访问哪一个磁盘驱动器，再确定应该访问该磁盘中的哪一个柱面，再确定应该访问的盘面，最后确定扇区。

### 磁盘工作过程

* 磁盘的主要操作是寻址、读盘、写盘，每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。
* 硬盘属于机械式部件，其读写操作是**串行**的，不可能在同一时刻即读又写，也不可能在同一时刻读两组数据或写两组数据

### 磁盘阵列

**RAID**（Redundant Array of Inexpensive Disks，廉价冗余磁盘阵列）是将多个独立的物理磁盘组成一个独立的逻辑盘，数据<u>在多个物理盘上分割交叉存储，并行访问</u>，具有更好的存储性能、可靠性和安全性。
RAID同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高存储系统带数据吞吐量；通过镜像功能提高安全可靠性；通过数据校验可以提供容错能力

RAID的分级如下所示：
* RAID0：无冗余和无校验的磁盘阵列。类比低位交叉编址的多体存储器，把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但没有容错能力
* RAID1：镜像磁盘阵列。为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可以从另一个磁盘中读出数据。两个磁盘当一个磁盘使用，容量减半。
* RAID2：采用纠错的海明码的磁盘阵列，逻辑上连续的几个bit物理上分散在各个盘中（4bit信息位+3bit海明校验位）——可纠正一位错（可联系[海明码](../4%20计算机网络/第3章%20数据链路层#海明码)）
* RAID3：位交叉奇偶校验的磁盘阵列，只能查错不能纠错
* RAID4：块交叉奇偶校验的磁盘阵列，类似RAID3，但对数据的访问是按数据块进行的
* RAID5：无独立校验的奇偶校验磁盘阵列
* RAID1~RAID5中等级越高，冗余信息占比越少，并通过数据校验容错能力越高

## 固态硬盘(SSD)

![固态硬盘SSD.pdf](附件/02.3.4.2%20固态硬盘SSD.pdf)

* **固态硬盘SSD**，Solid State Disk，基于闪存技术Flash Memory，属于电可擦除ROM，即EEPROM
* 一个固态硬盘包括一个或多个闪存翻译层和闪存芯片，其中**闪存翻译层**相当于磁盘的磁盘控制器，**闪存芯片**相当于磁盘的机械驱动器

### 读写性能特性

* 以页为单位读写，相当于磁盘的扇区
* 以块为单位擦除，擦除后的块其中每页都可以写一次，读无数次
* <u>读取快、写入慢</u>。若要写入的页中有数据，则不能写入。需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页（然后再将逻辑地址重新映射到新的位置）；另外，擦除块比较慢，通常比访问页高一个数量级
* 支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址

### 与机械硬盘相比的特点

* SSD读写速度快，随机访问性能高，用电路控制访问位置； 机械硬盘通过移动磁臂旋转到磁盘控制访问位置，有寻道时间和旋转延迟
* SSD安静无噪音，耐摔抗震，能耗低，造价高
* SSD的一个块如果被擦除次数过多（重复写同一个块）可能会坏掉，而机械硬盘不会

### 磨损均衡技术

* 实现思路：将“擦除”平均地分布在各个块上，以提升使用寿命
* **动态磨损均衡**：记录每个块的擦写次数，写入数据时优先使用累积擦除次数少的新闪块
* **静态磨损均衡**：擦写时优先把长久不用的数据从擦写次数少的块转移到擦写次数多的块，并将待写入的数据写入擦写次数少的块。即：让老旧的闪存块承担以读为主的存储任务，让较新的闪存块承担以写为主的存储任务

|     机制     |           优点           |             缺点             |
|:------------:|:------------------------:|:----------------------------:|
| 动态磨损均衡 | 实现简单，读写占用资源少 | 优化不足，磨损均衡的效果有限 |
| 静态磨损均衡 |  优化全面，提高整体寿命  |   实现困难，会增加擦写次数   | 

# 3.5 高速缓冲存储器

> 注意联系[快表](第3章%20内存管理#快表)

![Cache的基本原理.pdf](附件/01.3.5.1+3.5.2%20Cache的基本原理.pdf)
## 3.5.1 程序访问的局部性原理

* **空间局部性**：某个数据项在被访问之后，其地址周围相近的数据可能很快被访问
* **时间局部性**：某个数据项在被访问之后，可能很快会被再次访问

## 3.5.2 Cache 的基本工作原理

* Cache在存储器的层次化结构中位于CPU和主存之间，用来存放一段时间内被频繁访问的主存信息的副本。根据局部性原理，这段时间内CPU所需的信息基本都可在Cache里面找到，从而缓和了速度矛盾
* Cache被集成在CPU内部，用SRAM实现，速度快，成本高

Cache-主存层次的平均访问时间
* 设 $t_{c}$ 为访问一次Cache所需的时间，$t_{m}$ 为访问一次主存所需的时间
* **命中率** $H$：CPU想要访问的信息已经在Cache中的比率，$H=N_{c}/(N_{c}+N_{m})$
* **缺失率** $M$：$M=1-H$
* **平均访问时间** $t$ 
	* 先访问Cache，若Cache未命中再访问主存： $t=Ht_{c}+(1-H)(t_{c}+t_{m})$
	* 同时访问Cache和主存，若Cache命中则停止主存访问： $t=Ht_{c}+(1-H)t_{m}$
* 补充：Cache-主存系统的效率=Cache访问时间 $t_{c}$ /平均访问时间 $t$ #考前记一记 

关于“周围”
* 将主存的存储空间“分块”，主存与Cache之间以“块”为单位进行数据交换 
* 将主存的地址分为两部分，前面几位为“**块号**”，后面几位为“**块内地址**”
* 操作系统中，通常将主存中的“一个块”也称为“一个页/页面/页框”，Cache中的“块”也称为“行”
### Cache的组成

![第3章-Cache组成.drawio](图表/第3章-Cache组成.drawio.svg)
Cache的每一行不仅要存储对应主存块的数据，同时需要附设若干个辅助位
* **标记位**：大小取决于[地址映射策略](#3.5.3%20Cache%20和主存的映射关系)，标识Cache块对应哪一个主存块
* **有效位**：大小为1bit，标识该Cache块中的数据是否有效
* **脏位**：大小为1bit，仅当使用[写回法](#3.5.5%20Cache%20的一致性问题)时设置，标识该Cache块是否被修改过。
* **替换信息**：==待补充==
	* 全相联：$\log_{2}\text{行数}$
	* 组相联：$\log_{2}\text{路数}$。注意这里是路数而不是组数

## 3.5.3 Cache 和主存的映射关系

> 如何区分Cache与主存的数据块对应关系？
> 假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B。

![Cache和主存的映射方式.pdf](附件/02.3.5.3%20Cache和主存的映射方式.pdf)

* 给每个Cache块增加一个“标记”，指明它是主存中哪一块副本，相当于主存中块的编号；
* 由于主存块号也可能为零，为了区分，增加“有效位”，如果为零标记无效

**地址映射**是指把主存地址空间映射到Cache地址空间，即把存放在主存中的信息按照某种规则装入Cache

![Cache与主存的映射方式](pictures/第3章%20存储系统%20Cache与主存的映射方式.png)

### 全相联映射

![主存地址](图表/第3章-全相连映射.drawio.svg)
* **实现思路**：主存块可以装入Cache中的任意一块。（主存块号即为标记）
* CPU访问：主存块号即为标记，将标记与所有Cache块的Tag位进行比较，若标记匹配且有效位 $=1$ ，则Cache命中。
* 优点：Cache存储空间充分，命中率高
* 缺点：查找标记最慢，有可能需要对比所有块标记

### 直接映射

![主存地址](图表/第3章-直接映射.drawio.svg)
* **实现思路**：将主存块映射到固定且唯一的Cache块中。具体的映射关系为：<u>Cache块号=主存块号%Cache总块数</u>（相当于截取了主存块号的末尾几位，所以将主存块号中的其他位作为标记即可）标记的数量即为主存容量相对于Cache容量的倍数
* CPU的访问：先根据主存块号求得Cache块号和标记，再将标记与对应Cache块的Tag位进行比较，若标记匹配且有效位 $=1$ ，则Cache命中。
* 优点：实现简单，对于任意一个地址，只需要对比一个标记
* 缺点：Cache存储空间利用不充分，命中率低

### 组相联映射

![主存地址](图表/第3章-组相联映射.drawio.svg)
* **实现思路**：综合了全相联映射和直接映射方式的优点。将Cache块分为若干组，主存块可以装入到固定分组中的任意一块，即组间采用直接映射、组内采用全相联映射，具体的映射关系为：<u>组号=主存块号%分组数</u>（相当于截取了主存块号的末尾几位，所以将主存块号中的其他位作为标记即可）
* CPU的访问：先根据主存块号求得Cache组号和标记，再将标记与对应Cache组内所有Cache块的Tag位进行比较，若标记匹配且有效位 $=1$ ，则Cache命中。
* 优点：另外两种方式的折中，综合效果好
* 术语： $n$ **路组相联映射**——每 $n$ 个Cache块为一组，对应的比较器个数为 $n$

![第3章-组相联映射原理.drawio](图表/第3章-组相联映射原理.drawio.svg)

## 3.5.4 Cache 中主存块的替换算法

> Cache很小，主存很大，如果Cache满了怎么办？
> 联系操作系统[页面置换算法](第3章%20内存管理#3.2.4%20页面置换算法)进行学习

![Cache替换算法.pdf](附件/03.3.5.4%20Cache替换算法.pdf)

* 对于全相联映射：Cache完全满了才需要替换，需要在全局选择替换哪一块
* 对于直接映射：如果对应位置非空，直接替换，不需要考虑替换算法
* 对于组相联映射：分组满了才需要替换，需要在分组内选择替换哪一块

### 随机算法(RAND)

* Random，
* **实现思路**：从候选的Cache块中随机选取一块替换
* 实现简单，但完全没有考虑到局部性原理，实际效果很不稳定

### 先进先出算法(FIFO)

* First In First Out
* **实现思路**：选取现有Cache块中装入时间最早的一块替换
* 实现简单，但依然没有考虑到局部性原理，最先被调入Cache的块也有可能是被频繁访问的
* **抖动现象**：频繁地换入换出现象，刚被替换的块很快地又被调入

### **近期最少使用(LRU)**

* Least Recently Used，
* **实现思路**：选取现有Cache块中近期内长久未访问过的一块替换。具体的，为每一个Cache块设置一个“**计数器**”，用于记录每个Cache块已经有多久没有被访问了。当Cache满后替换“计数器”值最大的
* 实际做题中，当需要进行替换时，可以从当前位置往前看，查看哪些主存块是被访问过的<!--将Cache块的数量记为k，则只需要将0~k-1共k个数分配给各个块作为他们的优先级。命中时，命中的行优先级置为0，然后优先级比他之前低的全部上升一位，刚好可以填补命中行的空缺-->
	* 命中时，所命中的行的计数器清零，比其低的计数器加1，<u>其余不变</u>（若Cache块的总数 $=2^{n}$，则计数器只需要 $n$ 位，且Cache装满后所有计数器的值一定不重复） #考前记一记 
	* 未命中时，若仍有空闲行，新装入的行的计数器置0，其余非空闲行全部加1
	* 未命中且无空闲行时，计数值最大的信息块被淘汰，新装入的块计数器置0，其余全部加1
* 基于局部性原理，近期被访问过的主存块在不久的将来很可能被再次访问，因此淘汰最久没有访问过的块是合理的。其实际运行效果很优秀，命中率高
* 若频繁访问的主存块数量>Cache块的数量，则有可能发生**抖动现象**

### 最近不经常使用(LFU)

* Least Frequently Used
* **实现思路**：选取现有Cache块中近期访问次数最少的一块替换。具体的，为每个Cache块设置一个“**计数器**”，用于记录每个Cache块被访问过几次。当Cache满后替换“计数器”最小的
* 实现过程类似LRU
	* 新调入的块计数器 $=0$ ，之后每被访问一次计数器 $+1$ ，需要替换时，选择计数器最小的一行
	* 若有多个计数器最小的行，可按行号递增或FIFO策略进行选择
* 计数器的值可能会很大。曾经被经常访问的主存块在未来不一定会用到，并没有很好地遵循局部性原理，因此实际运行效果不如LRU

## 3.5.5 Cache 的一致性问题

> CPU修改了Cache中的数据副本，如何保证主存中数据母本的一致性？

![Cache写策略.pdf](附件/04.3.5.5%20Cache写策略.pdf)

* Cache中的内容是主存内容的副本，但是CPU对Cache的写操作会导致Cache与主存数据不一致，从而引发了Cache的一致性问题。解决Cache一致性问题的关键是处理好写操作：
* 写命中：针对写命中，有两种写操作方式
	* **写回法**：当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存；只有当此块被换出时才写回主存。
		* 需要增加“**脏位**”来表示Cache块是否被修改过。在Cache块换出时，若脏位为1则需要写回主存
	* **全写法**：当CPU对Cache写命中时，必须把数据同时写入Cache和主存。
		* 需要引入写缓冲，CPU在将数据写入Cache的同时也写入写缓冲，然后由写缓冲将需要写入的数据写回主存。
		* 当写请求过多时，可能会引发写缓冲的溢出。
* 写不命中：当写不命中时，有两种操作方式
	* **写分配法**：把主存中的块调入Cache，在Cache中修改，通常搭配写回法
	* **非写分配法**：只写入主存，不调入Cache，搭配全写法使用
* 多级Cache
	* Cache-主存之间常采用写回法+写分配法
	* 各级Cache之间常采用全写法+非写分配法

# 3.6 虚拟存储器

> 可联系操作系统[内存管理](../3%20操作系统/第3章%20内存管理)进行学习

## 3.6.1 虚拟存储器的基本概念

* 逻辑地址（虚地址）：程序员视角看到的地址，逻辑地址=逻辑页号+页内地址（虚地址=虚页号+页内地址）
* 物理地址（实地址）：实际在主存中的地址，物理地址=主存块号+页内地址（实地址=实页号+页内地址）
* 在虚拟存储器中，系统将需要的指令与数据先送入磁盘，然后操作系统将当前需要的指令与数据换入主存中，剩下暂时不用的留在磁盘中
* 程序运行时，CPU以逻辑地址来访问主存，由辅助硬件找出逻辑地址和物理地址之间的对应关系（地址映射），并判断这个虚拟地址指示的存储单元内容是否已经装入主存。如果已经在主存中，则直接访问主存相关位置；如果不在主存中，则将数据从外存换入主存中。如果换入时发现主存已满，则需要按照一定的替换策略将主存特定数据换出到外存以供新数据换入主存。

## 3.6.2 页式虚拟存储器

> 拆分成大小相等的页面，可以参考操作系统[基本分页管理](../3%20操作系统/第3章%20内存管理#3.1.4%20基本分页存储管理)

**页式存储系统**：一个程序（进程）在逻辑上被分为若干个大小相等的“页面”，“页面”大小和“块”的大小相同。每个页面可以离散地放入不同的主存块中。

**页表**：逻辑地址与物理地址的映射（页表数据在主存里，CPU查页表需要去主存→把页表项放入更高速的存储器，即**快表**）

快表(TLB)是一种“[相联存储器](#按存取方式分类)”，可以按内容寻访。

![第3章-请求分页中的地址变换过程.drawio](../3%20操作系统/图表/第3章-请求分页中的地址变换过程.drawio.svg)

* 快表中存储的是页表项的副本；
* Cache中存储的是主存块的副本

## 3.6.3 段式虚拟存储器

> 按照功能模块拆分，可以参考操作系统[分页存储管理](../3%20操作系统/第3章%20内存管理#3.1.4%20基本分页存储管理)、[分段存储管理](../3%20操作系统/第3章%20内存管理#3.1.5%20基本分段存储管理)

## 3.6.4 段页式虚拟存储器

> 先分段，后分页，可以参考操作系统中[段页式管理](../3%20操作系统/第3章%20内存管理#3.1.6%20段页式管理)

## 3.6.5 虚拟存储器与Cache的比较